<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>Python中的元类(metaclass)是什么? | </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../pass/README.html" />
    
    
    <link rel="prev" href="../chapter/README.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="2" data-basepath=".." data-revision="1415190338739">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Stackoverflow about Python
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="chapter/README.html">
            
                
                    <a href="../chapter/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         Python中关键字yield有什么作用?
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="2" data-path="123/README.html">
            
                
                    <a href="../123/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Python中的元类(metaclass)是什么?
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="pass/README.html">
            
                
                    <a href="../pass/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         Python中如何在一个函数中加入多个装饰器?
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="12/README.html">
            
                
                    <a href="../12/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         用Python如何检测一个文件是否存在?
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="5" data-path="1231/README.html">
            
                
                    <a href="../1231/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                         在Python中有三元运算符吗?
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="6" data-path="qwe/README.html">
            
                
                    <a href="../qwe/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                         在Python中调用外部命令?
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" ></a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_3130">
                    
                        <table>
<thead>
<tr>
<th style="text-align:center">rank</th>
<th style="text-align:center">▲</th>
<th style="text-align:center">✰</th>
<th style="text-align:center">vote</th>
<th style="text-align:center">url</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1919</td>
<td style="text-align:center">1842</td>
<td style="text-align:center">3137</td>
<td style="text-align:center"><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank">url</a></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="pythonmetaclass">Python中的元类(metaclass)是什么?</h2>
<p>元类是什么?如何使用元类?</p>
<hr>
<h4 id="">类对象</h4>
<p>在理解元类之前,你需要掌握Python里的类.Python中类的概念借鉴于Smalltalk，这显得有些奇特.</p>
<p>在大多数语言中,类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCreator</span><span class="hljs-params">(object)</span>:</span>
<span class="hljs-prompt">... </span>      <span class="hljs-keyword">pass</span>
...

<span class="hljs-prompt">&gt;&gt;&gt; </span>my_object = ObjectCreator()
<span class="hljs-prompt">&gt;&gt;&gt; </span>print(my_object)
&lt;__main__.ObjectCreator object at <span class="hljs-number">0x8974f2c</span>&gt;
</code></pre>
<p>但是在Python中类也是对象.</p>
<p>是的,对象.</p>
<p>每当你用到关键字<code>class</code>,Python就会执行它并且建立一个对象.例如:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCreator</span><span class="hljs-params">(object)</span>:</span>
<span class="hljs-prompt">... </span>      <span class="hljs-keyword">pass</span>
...
</code></pre>
<p>上面代码在内存里创建了名叫&quot;ObjectCreator&quot;的对象.</p>
<p>这个对象(类)有生成对象(实例)的能力,这就是为什么叫做类.</p>
<p>它是个对象,所以:</p>
<ul>
<li>你可以把它赋值给一个变量</li>
<li>你可以赋值它</li>
<li>你可以给它添加属性</li>
<li>你个以作为函数参数来传递它</li>
</ul>
<p>e.g.:</p>
<pre><code class="lang-python">&gt;&gt;&gt; print(ObjectCreator) # 你可以打印一个类,因为它是一个对象
&lt;class '__main__.ObjectCreator'&gt;
&gt;&gt;&gt; def echo(o):
...       print(o)
...
&gt;&gt;&gt; echo(ObjectCreator) # 你可以把类作为参数传递
&lt;class '__main__.ObjectCreator'&gt;
&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))
False
&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # 可以给一个类添加属性
&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))
True
&gt;&gt;&gt; print(ObjectCreator.new_attribute)
foo
&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 可以把类赋值给一个变量
&gt;&gt;&gt; print(ObjectCreatorMirror.new_attribute)
foo
&gt;&gt;&gt; print(ObjectCreatorMirror())
&lt;__main__.ObjectCreator object at 0x8997b4c&gt;
</code></pre>
<h4 id="">动态创建类</h4>
<p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。</p>
<p>首先，你可以在函数中创建类，使用class关键字即可:</p>
<pre><code class="lang-python">&gt;&gt;&gt; def choose_class(name):
...     if name == 'foo':
...         class Foo(object):
...             pass
...         return Foo # 返回一个类不是一个实例
...     else:
...         class Bar(object):
...             pass
...         return Bar
...
&gt;&gt;&gt; MyClass = choose_class('foo')
&gt;&gt;&gt; print(MyClass) # 返回一个类不是一个实例
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; print(MyClass()) # 你可以在类里创建一个对象
&lt;__main__.Foo object at 0x89c6d4c&gt;
</code></pre>
<p>但这还不够动态,因为你仍然需要自己编写整个类的代码.</p>
<p>既然类是对象,那么肯定有什么东西来生成它.</p>
<p>当你使用关键字<code>objects</code>,Python自动的创建对象.像Python中大多数的东西一样,他也给你自己动手的机会.</p>
<p>记得函数<code>type</code>吗?这个古老好用的函数能让你知道对象的类型是什么:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span>print(type(<span class="hljs-number">1</span>))
&lt;type <span class="hljs-string">'int'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>print(type(<span class="hljs-string">"1"</span>))
&lt;type <span class="hljs-string">'str'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>print(type(ObjectCreator))
&lt;type <span class="hljs-string">'type'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>print(type(ObjectCreator()))
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">__main__</span>.<span class="hljs-title">ObjectCreator</span>'&gt;</span>
</code></pre>
<p>这里,<code>type</code>有一种完全不同的能力,它也能动态的创建类.<code>type</code>可以接受一个类的描述作为参数,然后返回一个类.</p>
<p>(我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性)</p>
<pre><code class="lang-type```这样工作:">
```python
type(类名,
     父类名的元组 (针对继承情况,可以为空),
     包含属性的字典(名称和值))
</code></pre>
<p>e.g.:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyShinyClass</span><span class="hljs-params">(object)</span>:</span>
<span class="hljs-prompt">... </span>      <span class="hljs-keyword">pass</span>
</code></pre>
<p>可以手动创建:</p>
<pre><code class="lang-python">&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # 返回类对象
&gt;&gt;&gt; print(MyShinyClass)
&lt;class '__main__.MyShinyClass'&gt;
&gt;&gt;&gt; print(MyShinyClass()) # 创建一个类的实例
&lt;__main__.MyShinyClass object at 0x8997cec&gt;
</code></pre>
<p>你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。</p>
<pre><code class="lang-type```可以接受一个字典来定义类的属性:">
```python
&gt;&gt;&gt; class Foo(object):
...       bar = True
</code></pre>
<p>可以写成:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span>Foo = type(<span class="hljs-string">'Foo'</span>, (), {<span class="hljs-string">'bar'</span>:<span class="hljs-keyword">True</span>})
</code></pre>
<p>然后我们可以像用正常类来用它:</p>
<pre><code class="lang-python">&gt;&gt;&gt; print(Foo)
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; print(Foo.bar)
True
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; print(f)
&lt;__main__.Foo object at 0x8a9b84c&gt;
&gt;&gt;&gt; print(f.bar)
True
</code></pre>
<p>当然,你也可以继承它:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooChild</span><span class="hljs-params">(Foo)</span>:</span>
<span class="hljs-prompt">... </span>        <span class="hljs-keyword">pass</span>
</code></pre>
<p>这样:</p>
<pre><code class="lang-python">&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})
&gt;&gt;&gt; print(FooChild)
&lt;class '__main__.FooChild'&gt;
&gt;&gt;&gt; print(FooChild.bar) # bar从Foo继承
True
</code></pre>
<p>要是在类中添加方法,你要做的就是把函数名写入字典就可以了,不懂可以看下面:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">echo_bar</span><span class="hljs-params">(self)</span>:</span>
<span class="hljs-prompt">... </span>      print(self.bar)
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>FooChild = type(<span class="hljs-string">'FooChild'</span>, (Foo,), {<span class="hljs-string">'echo_bar'</span>: echo_bar})
<span class="hljs-prompt">&gt;&gt;&gt; </span>hasattr(Foo, <span class="hljs-string">'echo_bar'</span>)
<span class="hljs-keyword">False</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="hljs-string">'echo_bar'</span>)
<span class="hljs-keyword">True</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>my_foo = FooChild()
<span class="hljs-prompt">&gt;&gt;&gt; </span>my_foo.echo_bar()
<span class="hljs-keyword">True</span>
</code></pre>
<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p>
<h4 id="">什么是元类(终于到正题了)</h4>
<p>元类就是创建类的东西.</p>
<p>你是为了创建对象才定义类的,对吧?</p>
<p>但是我们已经知道了Python的类是对象.</p>
<p>这里,元类创建类.它们是类的类,你可以把它们想象成这样:</p>
<pre><code class="lang-python">MyClass = MetaClass()
MyObject = MyClass()
</code></pre>
<p>你已经看到了<code>type</code>可以让你像这样做：</p>
<pre><code class="lang-python">MyClass = type(<span class="hljs-string">'MyClass'</span>, (), {})
</code></pre>
<p>这是因为<code>type</code>就是一个元类.<code>type</code>是Python中创建所有类的元类.</p>
<p>现在你可能纳闷为啥子<code>type</code>用小写而不写成<code>Type</code>?</p>
<p>我想是因为要跟<code>str</code>保持一致,<code>str</code>创建字符串对象,<code>int</code>创建整数对象.<code>type</code>正好创建类对象.</p>
<p>你可以通过检查<code>__class__</code>属性来看到这一点.</p>
<p>Python中<strong>所有的东西</strong>都是对象.包括整数,字符串,函数还有类.所有这些都是对象.所有这些也都是从类中创建的:</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span>age = <span class="hljs-number">35</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>age.__class__
&lt;type <span class="hljs-string">'int'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>name = <span class="hljs-string">'bob'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>name.__class__
&lt;type <span class="hljs-string">'str'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span> <span class="hljs-keyword">pass</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>foo.__class__
&lt;type <span class="hljs-string">'function'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span><span class="hljs-params">(object)</span>:</span> <span class="hljs-keyword">pass</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>b = Bar()
<span class="hljs-prompt">&gt;&gt;&gt; </span>b.__class__
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">__main__</span>.<span class="hljs-title">Bar</span>'&gt;</span>
</code></pre>
<p>那么,<code>__class__</code>的<code>__class__</code>属性是什么?</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span>age.__class__.__class__
&lt;type <span class="hljs-string">'type'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>name.__class__.__class__
&lt;type <span class="hljs-string">'type'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>foo.__class__.__class__
&lt;type <span class="hljs-string">'type'</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>b.__class__.__class__
&lt;type <span class="hljs-string">'type'</span>&gt;
</code></pre>
<p>所以,元类就是创建类对象的东西.</p>
<p>如果你愿意你也可以把它叫做&#39;类工厂&#39;.<code>type</code>是Python的内建元类,当然,你也可以创建你自己的元类.</p>
<h4 id="__metaclass__"><code>__metaclass__</code>属性</h4>
<p>当你创建一个函数的时候,你可以添加<code>__metaclass__</code>属性:</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">(object)</span>:</span>
  __metaclass__ = something...
  [...]
</code></pre>
<p>如果你这么做了，Python就会用元类来创建类Foo.</p>
<p>小心点，这里面有些技巧.</p>
<p>你首先写下<code>class Foo(object</code>，但是类对象<code>Foo</code>还没有在内存中创建.</p>
<p>Python将会在类定义中寻找<code>__metaclass__</code>.如果找打了就用它来创建类对象<code>Foo</code>.如果没找到,就会默认用<code>type</code>创建类.</p>
<p>把下面这段话反复读几次。</p>
<p>当你写如下代码时 :</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">(Bar)</span>:</span>
  <span class="hljs-keyword">pass</span>
</code></pre>
<p>Python将会这样运行:</p>
<p>在<code>Foo</code>中有没有<code>___metaclass__</code>属性?</p>
<p>如果有,Python会在内存中通过<code>__metaclass__</code>创建一个名字为<code>Foo</code>的类对象(我说的是类对象,跟紧我的思路).</p>
<p>如果Python没有找到<code>__metaclass__</code>，它会继续在Bar（父类）中寻找<code>__metaclass__属性</code>，并尝试做和前面同样的操作.</p>
<p>如果Python在任何父类中都找不到<code>__metaclass__</code>，它就会在模块层次中去寻找<code>__metaclass__</code>，并尝试做同样的操作。</p>
<p>如果还是找不到<code>__metaclass__</code>,Python就会用内置的<code>type</code>来创建这个类对象。</p>
<p>现在的问题就是，你可以在<code>__metaclass__</code>中放置些什么代码呢？</p>
<p>答案就是：可以创建一个类的东西。</p>
<p>那么什么可以用来创建一个类呢？<code>type</code>，或者任何使用到<code>type</code>或者子类化<code>type</code>的东东都可以。</p>
<h4 id="">自定义元类</h4>
<p>元类的主要目的就是为了当创建类时能够自动地改变类.</p>
<p>通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类.</p>
<p>假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定<code>__metaclass__</code>.</p>
<p>采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>
<p>幸运的是，<code>__metaclass__</code>实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有&#39;class&#39;的东西并不需要是一个class，画画图理解下，这很有帮助）。</p>
<p>所以，我们这里就先以一个简单的函数作为例子开始。</p>
<pre><code class="lang-python"><span class="hljs-comment"># 元类会自动将你通常传给'type'的参数作为自己的参数传入</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upper_attr</span><span class="hljs-params">(future_class_name, future_class_parents, future_class_attr)</span>:</span>
  <span class="hljs-string">"""
    返回一个将属性列表变为大写字母的类对象
  """</span>

  <span class="hljs-comment"># 选取所有不以'__'开头的属性,并把它们编程大写</span>
  uppercase_attr = {}
  <span class="hljs-keyword">for</span> name, val <span class="hljs-keyword">in</span> future_class_attr.items():
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">'__'</span>):
          uppercase_attr[name.upper()] = val
      <span class="hljs-keyword">else</span>:
          uppercase_attr[name] = val

  <span class="hljs-comment"># 用'type'创建类</span>
  <span class="hljs-keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)

__metaclass__ = upper_attr <span class="hljs-comment"># 将会影响整个模块</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span>:</span> <span class="hljs-comment"># global __metaclass__ won't work with "object" though</span>
  <span class="hljs-comment"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span>
  bar = <span class="hljs-string">'bip'</span>

print(hasattr(Foo, <span class="hljs-string">'bar'</span>))
<span class="hljs-comment"># 输出: False</span>
print(hasattr(Foo, <span class="hljs-string">'BAR'</span>))
<span class="hljs-comment"># 输出: True</span>

f = Foo()
print(f.BAR)
<span class="hljs-comment"># 输出: 'bip'</span>
</code></pre>
<p>现在让我们再做一次，这一次用一个真正的class来当做元类。</p>
<pre><code class="lang-python"><span class="hljs-comment"># 请记住，'type'实际上是一个类，就像'str'和'int'一样</span>
<span class="hljs-comment"># 所以，你可以从type继承</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpperAttrMetaclass</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-comment"># __new__ 是在__init__之前被调用的特殊方法</span>
    <span class="hljs-comment"># __new__是用来创建对象并返回它的方法</span>
    <span class="hljs-comment"># 而__init__只是用来将传入的参数初始化给对象</span>
    <span class="hljs-comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span>
    <span class="hljs-comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span>
    <span class="hljs-comment"># 如果你希望的话，你也可以在__init__中做些事情</span>
    <span class="hljs-comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(upperattr_metaclass, future_class_name,
                future_class_parents, future_class_attr)</span>:</span>

        uppercase_attr = {}
        <span class="hljs-keyword">for</span> name, val <span class="hljs-keyword">in</span> future_class_attr.items():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">'__'</span>):
                uppercase_attr[name.upper()] = val
            <span class="hljs-keyword">else</span>:
                uppercase_attr[name] = val

        <span class="hljs-keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)
</code></pre>
<p>但是这不是真正的面向对象(OOP).我们直接调用了type，而且我们没有改写父类的<strong>new</strong>方法。现在让我们这样去处理:</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpperAttrMetaclass</span><span class="hljs-params">(type)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(upperattr_metaclass, future_class_name,
                future_class_parents, future_class_attr)</span>:</span>

        uppercase_attr = {}
        <span class="hljs-keyword">for</span> name, val <span class="hljs-keyword">in</span> future_class_attr.items():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">'__'</span>):
                uppercase_attr[name.upper()] = val
            <span class="hljs-keyword">else</span>:
                uppercase_attr[name] = val

        <span class="hljs-comment"># 重用 type.__new__ 方法</span>
        <span class="hljs-comment"># 这就是基本的OOP编程，没什么魔法</span>
        <span class="hljs-keyword">return</span> type.__new__(upperattr_metaclass, future_class_name,
                            future_class_parents, uppercase_attr)
</code></pre>
<p>你可能已经注意到了有个额外的参数<code>upperattr_metaclass</code>，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的<code>self</code>参数一样。</p>
<p>当然了，为了清晰起见，这里的名字我起的比较长。但是就像<code>self</code>一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpperAttrMetaclass</span><span class="hljs-params">(type)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, clsname, bases, dct)</span>:</span>

        uppercase_attr = {}
        <span class="hljs-keyword">for</span> name, val <span class="hljs-keyword">in</span> dct.items():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">'__'</span>):
                uppercase_attr[name.upper()] = val
            <span class="hljs-keyword">else</span>:
                uppercase_attr[name] = val

        <span class="hljs-keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)
</code></pre>
<p>如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpperAttrMetaclass</span><span class="hljs-params">(type)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, clsname, bases, dct)</span>:</span>

        uppercase_attr = {}
        <span class="hljs-keyword">for</span> name, val <span class="hljs-keyword">in</span> dct.items():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">'__'</span>):
                uppercase_attr[name.upper()] = val
            <span class="hljs-keyword">else</span>:
                uppercase_attr[name] = val

        <span class="hljs-keyword">return</span> super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)
</code></pre>
<p>就是这样，除此之外，关于元类真的没有别的可说的了。</p>
<p>使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。</p>
<p>确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：</p>
<ul>
<li>拦截类的创建</li>
<li>修改一个类</li>
<li>返回修改之后的类</li>
</ul>
<h4 id="metaclass">为什么要用metaclass类而不是函数?</h4>
<p>由于<code>__metaclass__</code>可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？</p>
<p>这里有好几个原因：</p>
<ul>
<li>意图会更加清晰。当你读到<code>UpperAttrMetaclass(type)</code>时，你知道接下来要发生什么。</li>
<li>你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。</li>
<li>你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。</li>
<li>你可以使用<code>__new__</code>,<code>__init__</code>以及<code>__call__</code>这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在<code>__new__</code>里处理掉，有些人还是觉得用<code>__init__</code>更舒服些。</li>
<li>哇哦，这东西的名字是metaclass，肯定非善类，我要小心！</li>
</ul>
<h4 id="tmd">说了这么多TMD究竟为什么要使用元类？</h4>
<p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？</p>
<p>好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p>
</blockquote>
<p>元类的主要用途是创建API。一个典型的例子是Django ORM。</p>
<p>它允许你像这样定义：</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span>
  name = models.CharField(max_length=<span class="hljs-number">30</span>)
  age = models.IntegerField()
</code></pre>
<p>但是如果你像这样做的话：</p>
<pre><code class="lang-python">guy = Person(name=<span class="hljs-string">'bob'</span>, age=<span class="hljs-string">'35'</span>)
print(guy.age)
</code></pre>
<p>这并不会返回一个<code>IntegerField</code>对象，而是会返回一个int，甚至可以直接从数据库中取出数据。</p>
<p>这是有可能的，因为<code>models.Model</code>定义了<code>__metaclass__</code>， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。</p>
<p>Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p>
<h4 id="">结语</h4>
<p>首先，你知道了类其实是能够创建出类实例的对象。</p>
<p>好吧，事实上，类本身也是实例，当然，它们是元类的实例。</p>
<pre><code class="lang-python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">(object)</span>:</span> <span class="hljs-keyword">pass</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>id(Foo)
<span class="hljs-number">142630324</span>
</code></pre>
<p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例.</p>
<p>除了<code>type</code>.<code>type</code>实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。</p>
<p>其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Monkey_patch" target="_blank">monkey patching</a></li>
<li>装饰器</li>
</ul>
<p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D</p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../chapter/README.html" class="navigation navigation-prev " aria-label="Previous page: Python中关键字yield有什么作用?"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../pass/README.html" class="navigation navigation-next " aria-label="Next page: Python中如何在一个函数中加入多个装饰器?"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
